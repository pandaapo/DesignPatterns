>单例模式：
确保一个类在任何情况下在内存中都绝对只有一个实例。
>* 代码特点：提供一个全局访问点，隐藏其所有的构造方法。
>* 优点：减少内存开销，避免对资源的多重占用。
>* 缺点：没有接口，扩展困难。如果需要扩展单例对象，只有修改代码。

# 饿汉式单例
在单例类加载的时候立即初始化，并创建单例对象。
* 代码特点：一种是通过静态属性创建；一种是通过静态代码块创建
* 优点：绝对线程安全；没有锁，执行效率比较高；用户体验上比懒汉式更好。
* 缺点：因为在单例类首次加载时就创建实例，无论实例是否被使用，所以浪费内存空间。

# 懒汉式单例
在被外部类调用的时候内部类才会加载。
* 优点：在被外部类调用时才创建实例，所以节省内存空间。
* 缺点：因为存在线程安全问题 > 加锁（双重检查锁）--锁会影响性能--> 静态内部类 --反射破坏-->修改构造方法

```
序列化和反序列化会破坏单例：增加readResolve()方法。
```

# 注册式单例
将每一个实例都缓存到统一的容器中，使用唯一标识获取实例
## 枚举式
* 优点：（==因为是通过类名和Class对象类找到一个唯一的枚举对象？？？==）不会被反序列化破坏；jdk不允许通过反射创建枚举，所以也不会被反射破坏。
* 缺点：有着饿汉式单例的缺点
* 特点：（通过反编译工具，可以看出）是一种饿汉式单例。
## 容器式
* 优点：适用于实例非常多的情况，便于管理。
* 缺点：线程不安全（所以需要加synchronized）
## ThreadLocal式
* 优点：保证线程内部的全局唯一
* 缺点：跨线程时是多个实例。
* 特点：将所有对象放到ThreadLocalMap中。